#!/usr/bin/env python

"""
carry out force-field calculation (and possibly MOPAC/PM7 calc afterwards)
for a molecule identified with SMILE string `smi using Openbabel and then
write xyz file
"""

import numpy as np
import os,sys
import multiprocessing
import aqml.cheminfo.rdkit.rdmol as crk 
import argparse as ap #aqml.util.stropr as so

T,F = True,False
dic = {'T':T, 'F':F}


def smi2xyz(ipt):
    #assert os.popen('which python').read().strip() == '/usr/bin/python'
    ff, smi, label, optg2, glob, debug = ipt 
    # geometry generated by openbabel is boolshit sometimes;
    # RDKit, however, can produce high very descent geometries
    # as knowledges from experimental geometries can be used!!
    o = crk.RDMol(smi, forcefield=ff, debug=debug)
    o.optg()
    if glob: # search for global minimum
        o.get_stablest_conformer()
    #atoms = cc.atoms(o.zs, o.coords)
    if optg2:
        o.optg2(label)
    o.write_sdf( label + '.sdf' )
    fn = label + '.xyz'
    o.write_xyz(fn) #, [atoms], format='xyz')


ps = ap.ArgumentParser()

ps.add_argument('-np','--nproc', dest='np', default=1, type=int, help='number of cpus to be used for multiprocessing, default: no multithreading, i.e., np=1')
ps.add_argument('-ff','--force-field', dest='ff', default='mmff94', type=str, help='the name of force field to be used for geom opt, default: MMFF94')
ps.add_argument('-optg2', '-pm7', dest='optg2', action='store_true', help='use MOPAC/PM7 to refine geometry?')
ps.add_argument('-ow','--overwrite', dest='ow', action='store_true', help='overwrite existing files?')
ps.add_argument('-glob', '--global-minima', dest='glob', type=bool, default=True, help='search for global minima? defaulted to True')
ps.add_argument('-type', '--type-of-input', dest='type', type=str, help='the type of input objects, being smi/txt/sdf')
ps.add_argument('-nj','--njobs', dest='nj', type=int, default=1, help='total number of job splits')
ps.add_argument('-i', '--job-index', dest='i', type=int, default=0, help='job index, must be within [0,nj]')

ps.add_argument('-debug', action='store_true', help='debug the script?')

ps.add_argument('args', type=str, nargs='*', help='input molecules for processing')


ag = ps.parse_args(sys.argv[1:])

ncpu = ag.np
ff = ag.ff
optg2 = ag.optg2

nj = ag.nj
id = ag.i
assert id>=0 and nj-id>=1
args = ag.args


#keys = ['-names']; has_names,names,idx = so.parser(args,keys,None,idx)

named = F
names = []
if ag.type == 'smi':
    _objs = []
    _names = []
    for arg in args:
        if ag.debug:
            print(' -- arg = ', arg)
        if os.path.exists(arg):
            for s0 in open(arg).readlines():
                s1 = s0.strip()
                if s1 == '':
                    continue
                ss1 = s0.split()
                n1 = len(ss1)
                if n1 > 1:
                    if ss1[1][0] != '#':
                        print('#ERROR: for file *.smi with >1 entries per line, please let sep="#"')
                        sys.exit(2)
                    smi1 = ss1[0]
                    fn1 = ss1[2] if ss1[1]=='#' else ss1[1][1:]

                    if not fn1.isascii():
                        raise Exception('#ERROR: when >=2 entries are present in each line, the second must be an ASCII string as file ID')

                    if fn1.isdigit(): 
                        fn1 = 'frag_'+fn1

                else:
                    smi1 = s1
                    fn1 = ''
                _objs += [smi1]
                _names += [fn1]
        else:
            _objs.append(arg)
            _names.append('')
    if ag.debug:
        print('_objs=', _objs, '_names=',_names)
    nmt = len(_objs)
    fmt = 'frag_%%0%dd'%( len(str(nmt)) ) 
    objs = []
    for i,obj in enumerate(_objs):
        namei = fmt%(i+1) if _names[i] == '' else _names[i]
        names.append(namei)
        if not os.path.exists(namei+'.xyz'):
            objs += [obj]

    if ag.debug:
        print('objs=', objs, 'names=',names)
elif ag.type == 'txt': # two columns: smiles & id
    objs = []
    for arg in args:
        if ag.debug:
            print(' -- arg = ', arg)
        if not os.path.exists(arg):
            raise Exception('#ERROR: txt file does not exist??')
        for si in open(arg).readlines():
            siu = si.strip()
            if siu != '':
                b, a = siu.split()[:2]
                name = 'frag_%s'%a
                if not os.path.exists(name+'.xyz'):
                    names += [name]
                    objs += [b]
elif ag.type == 'sdf':
    objs = args
    names = [ obj[:-4] for obj in objs ]
else:
    raise '#ERROR: unknow input type'
if ag.debug:
    print(objs )

nm = len(objs)
if nj > 1:
    _nav = int(np.floor(nm*1.0/nj))
    if abs(nm-nj*_nav)<=1e-8: 
        nav = _nav
    else:
        nav = _nav + 1 #if nm%nj > 0 else nm/nj
    _fns = []; _ms = []
    i1 = id*nav; i2 = (id+1)*nav
    if i2 > nm: i2 = nm
    #if isub: 
    if not os.path.exists(sid): os.system('mkdir %s'%sid)
    fdo = sid + '/'
else:
    i1,i2 = 0,nm
    fdo = './'

#print('i1,i2=',i1,i2)
objs_i = objs[i1:i2]
names_i = [ fdo+fni for fni in names[i1:i2] ]
#print('objs_i,names_i=', len(objs_i),len(names_i))

ipts = []
debug = F if ncpu > 1 else T
for i,obj in enumerate(objs_i):

    name = names_i[i]
    if ag.ow or (not os.path.exists(name+'.xyz')):
        ipts.append( [ff, obj, name, optg2, ag.glob, debug] )

if ncpu > 1:
    print('multiprocessing!')
    pool = multiprocessing.Pool(processes=ncpu)
    pool.map(smi2xyz, ipts)
else:
    print('sequential processing!')
    for ipt in ipts:
        print(' now processing %d/%d'%(i+1, nm))
        print(ipt[1],ipt[2])
        smi2xyz(ipt)

#if qcl != None:
#  for name in names:
#    os.system("xyz2com -n 6 -m '%s' %s.xyz"%(qcl,name))

