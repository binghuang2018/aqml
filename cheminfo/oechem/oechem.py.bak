# -*- coding: utf-8 -*-

from openeye import *
from openeye.oechem import *
import networkx as nx
import itertools as itl
import scipy.spatial.distance as ssd
import multiprocessing

import numpy as np
import ase.io as aio
import ase.data as ad
import ase, os, sys, re, copy

import aqml.cheminfo as co
import aqml.cheminfo.core as cc

import aqml.cheminfo.math as cim
from aqml.cheminfo.molecule.elements import Elements
import aqml.cheminfo.molecule.core as cmc
import aqml.cheminfo.molecule.geometry as GM
import aqml.cheminfo.molecule.nbody as MB
import aqml.cheminfo.rdkit.resonance as crr
import aqml.cheminfo.oechem.core as coc

import aqml.cheminfo.rw.ctab as crc
from rdkit import Chem


# reference coordination number
#cnsr = {1:1, 3:1, 4:2, 5:3, 6:4, 7:3, 8:2, 9:1, 13:3, 14:4, 15:3, 16:2, 17:1, 35:1, 53:1}

T,F = True,False


#class Match(object):
#    def __init__(self, mols_q, mol_t, smiles=None):
#        if smiles is None:
#            smiles =
#        patt = smi2patt(smiles)
#
#    def filter(self,thresh):
#        matches = []
#        return icsr



def sdf2oem(sdf):
    ifs = oemolistream()
    assert ifs.SetFormat( dic_fmt[ sdf[-3:] ] )
    assert ifs.open(sdf)
    for m in ifs.GetOEGraphMols(): #.next()
        break
    return m

def pdb2oem(f):
    return sdf2oem(f)

def oem2can(oem, ImpHCount=F, rebuild=F):
    # ISOMERIC identical to Isotopes | AtomStereo | BondStereo | Canonical | AtomMaps | RGroups
    if ImpHCount:
        flavor = OESMILESFlag_ImpHCount | OESMILESFlag_Canonical
    else:
        flavor = OESMILESFlag_Canonical
    m = rebuild_m(oem) if rebuild else oem
    return OECreateSmiString(m, flavor)

def oem2smi(oem, ImpHCount=F, rebuild=F):
    return oem2can(oem, ImpHCount=ImpHCount, rebuild=rebuild)

def smi2oem(smi, addh=False):
    m = OEGraphMol()
    iok = OESmilesToMol(m,smi)
    #assert iok, '#ERROR: parsing SMILES failed!'
    if addh:
        OEAddExplicitHydrogens(m)
    else:
        OESuppressHydrogens(m,F,F,F)
    return iok, m

def rebuild_mol(m):
    mu = OEGraphMol()
    atoms = {}; icnt = 0
    for ai in m.GetAtoms():
        ia = ai.GetIdx()
        zi = ai.GetAtomicNum()
        if zi > 1:
            aiu = mu.NewAtom( zi )
            aiu.SetHyb( OEGetHybridization(ai) )
            aiu.SetImplicitHCount( ai.GetImplicitHCount() )
            atoms[ icnt ] = aiu
            icnt += 1
    for bi in m.GetBonds():
        p, q = bi.GetBgnIdx(), bi.GetEndIdx()
        biu = mu.NewBond( atoms[p], atoms[q], bi.GetOrder() )
    OEFindRingAtomsAndBonds(mu)
    OEAssignAromaticFlags(mu, OEAroModel_OpenEye)
    OECanonicalOrderAtoms(mu)
    OECanonicalOrderBonds(mu)
    return mu

def get_bom(m):
    na = m.NumAtoms()
    bom = np.zeros((na,na), dtype=int)
    for bi in m.GetBonds():
        i,j,boij = bi.GetBgnIdx(), bi.GetEndIdx(), bi.GetOrder()
        bom[i,j] = bom[j,i] = boij
    return bom

def get_coords(m):
    coords = []
    for ai in m.GetAtoms():
        coords_ai = m.GetCoords(ai)
        coords.append( coords_ai )
    return np.array(coords,dtype=float)

def vang(u,v):
    cost = np.dot(u,v)/(np.linalg.norm(u) * np.linalg.norm(v))
# sometimes, `cost might be 1.00000000002, then np.arccos(cost)
# does not exist!
    u = cost if abs(cost) <= 1 else 1.0
    return np.arccos( u )*180/np.pi


def prepare_protein(f):
    m = pdb2oem(f)
    OESuppressHydrogens(m, F, F, F)

    lig = oechem.OEGraphMol()
    prot = oechem.OEGraphMol()
    wat = oechem.OEGraphMol()
    other = oechem.OEGraphMol()
    assert oechem.OESplitMolComplex(lig, prot, wat, other, m)

    OERemoveFormalCharge(prot) # note that for quaternary amines (>[N+]<), charges retain
    OEAddExplicitHydrogens(prot)
    OESet3DHydrogenGeom(prot)
    f2 = f[:-4]+'-new.pdb'
    write(prot,f2)
    write(prot,f[:-4]+'-new.xyz')
    obj = StringM(f2)
    obj.check_valence_states()
    #obj.check_interatomic_distance()
    #assert iok


class XYZMol(object):
    """
    perceive BO from geom by OEChem
    """
    def __init__(self, fx):
        ifs = oemolistream()
        assert ifs.SetFormat( dic_fmt['xyz'] )
        assert ifs.open(fx)
        for mol in ifs.GetOEGraphMols(): #.next()
            break
        oechem.OEDetermineConnectivity(mol)
        oechem.OEFindRingAtomsAndBonds(mol)
        oechem.OEPerceiveBondOrders(mol)
        oechem.OEAssignImplicitHydrogens(mol)
        oechem.OEAssignFormalCharges(mol)
        self.mol = mol

    @property
    def g(self):
        return


class ConnMol(cmc.RawMol):
    """
    Mol with connectivity only
    No bond order perceived
    """
    def __init__(self, obj, ivdw=False, scale=1.0, iprt=F):
        cmc.RawMol.__init__(self, obj, ivdw=ivdw, scale=scale, iprt=iprt)

    def get_mol(self):
        return coc.newmol(self.zs, np.zeros(self.na), self.g, self.coords).mol

    @property
    def mol(self):
        if not hasattr(self, '_mol'):
            self._mol = self.get_mol()
        return self._mol

    def get_strained(self):
        return np.any( [ [ OEAtomIsInRingSize(ai, n) for n in [3,4,5,7] ] for ai in self.mol.GetAtoms() ] )

    @property
    def strained(self):
        if not hasattr(self, '_strained'):
            self._strained = self.get_strained()
        return self._strained

    @property
    def is_mcplx(self): # is mol complex?
        if not hasattr(self, '_imcplx'):
            self._imcplx = (not self.is_connected)
        return self._imcplx


class StringM(coc.newmol):

    """
    build molecule object with a string (SMILES or sdf file) as input
    """

    def __init__(self, obj, stereo=F, isotope=F, suppressH=F, ImpHCount=F, \
                 simple=F, purge_charge=F, debug=F):

        self.suppressH = suppressH
        self.ImpHCount = ImpHCount
        self.purge_charge = purge_charge
        self.debug = debug
        istat = T
        if isinstance(obj, str):
            string = obj
            if os.path.exists(string):
                if string.endswith( ('sdf','mol','pdb') ):
                    m = sdf2oem(string)
                    #print('######################')
                    if suppressH:
                        OESuppressHydrogens(m, F, F, F)
                else:
                    raise Exception('#ERROR: file type not supported')
                if suppressH:
                    OESuppressHydrogens(m, False, False, False)
            else: # presumably a SMILES string
                #print('------------------------')
                if ('@' in string) and (not stereo):
                    # now remove stereo and isotopes, otherwise we may
                    # encounter error " idx out of bound when calling get_bom()
                    istat, _m = smi2oem(string)
                    _s = OECreateSmiString(_m, OESMILESFlag_Canonical)
                else:
                    _s = string
                istat, m = smi2oem(_s)
                if istat and (not suppressH):
                    iok = OEAddExplicitHydrogens(m)
        elif isinstance(obj, oechem.OEGraphMol):
            m = obj
        else:
            raise Exception('#ERROR: input `string not supported')

        self.istat = istat
        if not istat:
            raise Exception('istat is False??')

        self.oem = m

        na = m.NumAtoms()
        zs = []; chgs = []
        for ai in m.GetAtoms():
            zs.append( ai.GetAtomicNum() )
            chgs.append( ai.GetFormalCharge() )
        self.chgs = np.array(chgs,dtype=int)
        self.zs = np.array(zs,dtype=int)
        self.na = na
        self.ias = np.arange(na)
        self.nheav = (self.zs>1).sum()

        self.bom = get_bom(m)
        self.tvs = self.bom.sum(axis=0)
        if simple: return #

        self.coords = get_coords(m)
        self.isorted = F
        if 1 in zs:
            ih1 = zs.index(1)
            if np.any(self.zs[ih1:] > 1):
                print(' ***** hydrogens were pushed to the end')
                self.sort()
        self.iasv = self.ias[self.zs>1]
        self.zsv = self.zs[self.iasv]
        #if self.purge_charge:
        #    self.annihilate_chgs()
        self.can = oem2can(self.oem, ImpHCount=ImpHCount, rebuild=F)
        self.g = (self.bom>0).astype(np.int)
        self.cns = self.g.sum(axis=0)
        self.cnsv = np.array([(self.zs[self.g[ia]>0]>1).sum() for ia in self.ias])
        self.cnsvv = self.cnsv[self.iasv]

    @property
    def symbols(self):
        if not hasattr(self, '_symb'):
            self._symb = [ cc.chemical_symbols[zi] for zi in self.zs ]
        return self._symb

    @property
    def valences(self):
        """ total valences """
        if not hasattr(self,'_val'):
            self._val = self.bom.sum(axis=0) - self.chgs
        return self._val

    @property
    def ds(self):
        if not hasattr(self,'_ds'):
            self._ds = ssd.squareform( ssd.pdist(self.coords) )
        return self._ds

    @property
    def iasr5(self): # contains 5/6-membered ring?
        if not hasattr(self, '_iasr5'):
            iasr5 = np.array([ OEAtomIsInRingSize(ai,5) for ai in self.oem.GetAtoms() ])
            self._iasr5 = self.ias[ iasr5 ]
        return self._iasr5

    @property
    def i5r(self): # contains 5/6-membered ring?
        if not hasattr(self, '_i5r'):
            self._i5r = ( len(self.iasr5)>0 )
        return self._i5r

    @property
    def iasr6(self): # contains 5/6-membered ring?
        if not hasattr(self, '_iasr6'):
            iasr6 = np.array([ OEAtomIsInRingSize(ai,6) for ai in self.oem.GetAtoms() ])
            self._iasr6 = self.ias[ iasr6 ]
        return self._iasr6

    @property
    def i6r(self): # contains 5/6-membered ring?
        if not hasattr(self, '_i6r'):
            self._i6r = ( len(self.iasr6)>0 )
        return self._i6r

    @property
    def resonated(self):
        """ normal resonace due to Pi-electron delocalization, e.g.,
        benzene ring """
        if not hasattr(self, '_resonated'):
            self._resonated = self.get_is_resonated()
        return self._resonated

    def get_is_resonated(self):
        """ a mol is resonated if the number of alternave structures .lt. 1 """
        obj = crr.ResonanceEnumerator(self.rdmol, kekule_all=T)
        tf = ( obj.nmesomers > 1 )
        return tf

    @property
    def resonated_cs(self):
        """ resonance due to Charge Seperation (cs)
        This exists mainly in aromatic mols containing -C(=O)N-
        """
        if not hasattr(self, '_resonated_cs'):
            self._resonated_cs = self.get_is_resonated_cs()
        return self._resonated_cs

    def get_is_resonated_cs(self):
        patt = '[#6;a](=[#8,#16])[#7;a]'
        tf, _, _ = is_subg(self.oem, patt)
        return tf

    # 5-membered aromatic ring with substitutes is also considered resonated!

    def get_istrains(self):
        istrains = np.array([F]*self.nheav, dtype=bool)
        _ias = set()
        for ats in self.atsr_strain:
            _ias.update(ats)
        istrains[list(_ias)] = T
        return istrains

    @property
    def istrains(self):
        if not hasattr(self, '_istrains'):
            self._istrains = self.get_istrains()
        return self._istrains

    @property
    def is_conj_amon(self):
        """
        is it a benzene ring (Ph) with attached functional groups (R) mesomeric
        """
        if not hasattr(self, '_meso'):
            self._meso = self.get_is_conj_amon()
        return self._meso


    def get_is_conj_amon(self):
        """
        Tell if the molecule is a conjugated amon (to be selected for training) through
        mainly three criterias:
          a) are all atoms involved conjugated or hyper-conjugated (via sigma or pi)?
             E.g., c6h5-CH3: sigma hyper-conj; c6h5-OH: pi hyper-conj
          b) resonated? I.e., number of resonance structures > 1
          c) contains 6-membered aromatic ring?

        :return: A list of all possible resonance forms of the molecule.
        :rtype: list of rdkit.Chem.rdchem.Mol
        """
        zsh = self.zs[self.zs>1]
        iconjs = self.iconjs
        nheav = self.nheav
        NI = 8 # 9
        if not (nheav<=NI and all(iconjs) and np.any(self.aromatic) and self.i6r): # (self.i5r or self.i6r)):
            return F
        #if (self.i5r and self.i6r):
        #    return F # E.g., nucleobase A (Adenine) without -NH2 group
        if nheav <= 7:
            return T
        patt = '[a]-[A;#6,#7,#8,#9,#16,#17]'
        imth, _idx, _ = is_subg(self.oem, patt, iop=1)
        idx = [ i[-1] for i in _idx ]
        n = len(idx)

        tf = F
        #if self.i5r:
        #    if n <= 2 and nheav <= 8:
        #        if (iconjs==3).sum() <= 1:
        #            # allow at most 1 attached group interacting via sigma-hyperconj
        #            tf = T  # E.g., C-c1ccnN1(C=O)
        if self.i6r:
            if (self.resonated or self.resonated_cs):
                if n == 0:
                    tf = T
                elif n == 1:
                    #if self.resonated:
                    #    if all(iconjs==1):
                    #        tf = T # Ph-R (R is -CH=O, -CH=CH2, -C#N, -C=N#N, -N=N#N, ...)
                    #    else:
                    #        zs_hc = zsh[iconjs==2] #  hyperconjugated due to Lone-p-electron and Pi e
                    #        nhc = len(zs_hc)
                    #        # for R = {-C(=O)F, -C(=O)Cl, }
                    #        # Don't include Ph-C(=O)N<, as C(=O)N is not coplanar with Ph after optg
                    #        if nhc==1 and (zs_hc[0] in [9,16,17]):
                    #            tf = T
                    if self.resonated_cs:
                        tf = T
        return tf

    def get_strained(self):
        # get a list of strains for each atom
        strains = []
        for ai in self.oem.GetAtoms():
            istrain = False
            if OEAtomIsInRingSize(ai, 3) or OEAtomIsInRingSize(ai, 4):
                istrain = True
            strains.append(istrain)
        return np.array(strains)

    def is_overcrowded(self):
        ds = ssd.squareform( ssd.pdist(self.coords) )
        non_bonds = np.where( np.logical_and(self.bom==0, ds!=0.) )
        rcs = Elements().rcs[ self.zs ]
        dsmin = rcs[..., np.newaxis] + [rcs]
        return np.any(ds[non_bonds]<dsmin[non_bonds])

    @property
    def aseobj(self):
        if not hasattr(self, '_ase'):
            self._ase = ase.Atoms(self.zs, self.coords)
        return self._ase

    def has_standalone_charge(self):
        hsc = False
        iasc = self.ias[self.chgs!=0]
        nac = len(iasc)
        if nac > 0:
            chgsc = self.chgs[iasc]
            gc = self.g[iasc][:,iasc]
            cliques = find_cliques(gc)
            for csi in cliques:
                if np.sum(chgsc[csi])!=0:
                    hsc = True
                    break
        return hsc

    def is_radical(self):
        irad = False
        if sum(self.zs)%2 == 1:
            irad = True
        else:
            vs = self.bom.sum(axis=0) - self.chgs
            for i in range(self.nheav):
                if vs[i] not in tvsr[ self.zs[i] ]:
                    print( self.zs[i], vs[i], tvsr[self.zs[i]])
                    irad = True
                    break
        return irad

    @property
    def saturated(self):
        if not hasattr(self, '_sat'):
            self._sat = self.get_is_saturated()
        return self._sat

    def get_is_saturated(self):
        sat = np.array([T]*self.na, dtype=np.bool)
        for i in self.iasv:
            if self.valences[i] not in tvsr[ self.zsv[i] ]:
                sat[i] = F
        return sat

    @property
    def aromatic(self):
        """
        Tell if a mol is aromatic by checking the existence of any aromatic atom
        """
        if not hasattr(self, '_aromatic'):
            #_aromatic = np.array([ F ]*self.na, dtype=bool)
            #if self.resonated or self.resonated_cs:
            _aromatic = np.array([ ai.IsAromatic() for ai in self.oem.GetAtoms() ], np.bool)
            self._aromatic = _aromatic
        return self._aromatic

    @property
    def rdmol(self):
        """ RDKit molecule object """
        ctab = crc.write_ctab(self.zs, self.chgs, self.bom)
        return Chem.MolFromMolBlock(ctab)

    @property
    def hybs(self):
        """ hybridization states """
        if not hasattr(self, '_hybs'):
            _hybs = np.array([ oechem.OEGetHybridization(ai) for ai in self.oem.GetAtoms() ], dtype=int)
            self._hybs = _hybs[self.zs > 1]
        return self._hybs

    @property
    def icisclose(self):
        """
        detect if the following cis-structure exists. Due to the fact that the two
        H's are too close, barely representing any local structure in query (typically
        a 5- or 6-membered ring, thus it's not gonna be considered as an amon!

                R2         R3
                 \        /
                  \______/
                  //    \\
          R1 ____//      \\___ R4
                 \        /
                  \      /
                   H     H               (Note: C atom in the chain may also be N atom)

            Just realized that this structure can be avoided by constraining not
            to break a 6-membered ring by removing two atoms!!
            Or alternatively, ensure that d(H,H) > 1.8 Ang is satisfied for any extracted
            local structure in the first place, without geom opt in any form (partial or full).
        """
        tf = F
        #ts = is_subg(self.oem, '[H][#6,#7;]~?~?[H]', iop=1)[1] # including >N-C=R (R=C<,N-,O)
        return tf

    @property
    def inotcrowd(self):
        """ is not crowd? T/F
        This function tell if the mol is genericly non-crowded
        """
        if not hasattr(self, '_inotcrowd'):
            tf = F
            nas = [6]
            patts = ['*~1' + '~*'*3 + '~*1~[!X1]', \
                    ] # first patt is a 5-membered ring with one R-group
            for i,patt in enumerate(patts):
                if self.nheav==nas[i] and is_subg(self.oem, patt, iop=1)[0]:
                    tf = T
                    break
            self._inotcrowd = tf
        return self._inotcrowd

    @property
    def iflex(self):
        """ hybridization states (corrected): i.e., for  >N-, hyb reset to 1, even for >N-C=O
            # now kick out amons that are flexible, which are easy to learn """
        if not hasattr(self, '_iflex'):
            #hybs = self.hybs
            # fix for N,
            #for ia in self.iasN3_nar:
            #    hybs[ia] = 3
            #    #print('hyb of ia=%d reset to 3'%ia)
            iflex = F
            iash = self.iasv

            cobj = self.cobj # self.cobj_ext # _ext: HB included
            pls = cobj.pls

            zs = self.zs
            icjs = self.iconjs

            pls_heav = pls[iash][:,iash]
            L0 = np.max(pls_heav)
            print('  max path length = ', L0)

            iasmult = self.iasP5orS6
            iasr5 = self.iasr5
            iasr5nv = np.setdiff1d(iasr5, iasmult)
            iasr6 = self.iasr6
            iasr56 = np.union1d(iasr5,iasr6)
            cnsv5 = self.cnsv[iasr5nv]

            Lm = 3
            infd = T

            if L0>=Lm and len(iasr5)>0 and (np.any(cnsv5>3) or (cnsv5>=3).sum()>1):
                # if it's a 5-membered conj or non-conj ring with either
                # a) more than 1 attached -R, or
                # b) heavy degree of any atom >3
                #  return as flexible directly
                iflex = T; infd = F

            if infd:
                ic4s = np.logical_and(self.zsv==6, self.cnsvv==4)
                nc4 = ic4s.sum()
                if L0==Lm and nc4>=1 and len(iasr56)==0:
                    # I.e., CC(C)(C)-C(C)C is not flexible
                    iflex = F; infd = F

            # is it a mol with i) PL0>3 and ii) contains C atom with any CN==4
            if infd and L0>Lm and nc4>0:
                iflex = T; infd = F

            # remove any 6- or 7-membered ring comprising of atoms that are all sp3-hyb
            if infd and np.all(icjs==0) and self.nheav>=6 and (self.cnsvv>=2).sum()>=6:
                iflex = T; infd = F

            if not infd:
                self._iflex = iflex
                return self._iflex
            else:
                if L0 > Lm:
                    #raise Exception('Todo: current implementation not perfect!')
                    tfs = (np.triu(pls_heav) > Lm)
                    pairs = np.array( np.where(tfs), dtype=int ).T
                    #print('pairs=', pairs)
                    paths = []
                    for i,atsi in enumerate(pairs):
                        ia1, ia2 = [ int(vi) for vi in iash[atsi] ]
                        path = cobj.get_shortest_path(ia1,ia2)
                        paths.append(path)

                    # a) L0=Lm+1 and
                    # b) only one such path and
                    # c) such path comprises of atoms that are all conj (iconj could be 1,2)
                    impl4conj = F # is maximal pl .eq. 4 and associated atoms (along the path) are conj
                    atsr56 = list( set( list(iasr5) + list(iasr6) ) )
                    #print('path=',path)#'iconjs=',self.iconjs[path], 'atsr56=',atsr56)
                    if len(paths)==1 and L0==Lm+1:
                        path = paths[0]
                        atsrc = np.intersect1d(path,atsr56) # ats in ring, that are common to path[0] and atsr56
                        if np.all(icjs[path]) and len(atsrc)>0:
                            impl4conj = T
                    print( '  impl4conj=',impl4conj)

                    # maxpl = 4, one end bond has to satisfy BO>1
                    # E.g., CCOC=O
                    impl4ebc = F
                    if L0==Lm+1 and self.nheav<=5:
                        iebcs = []
                        #print('paths = ', paths)
                        for path in paths:
                            #print('      path=', path)
                            if len(path)==5: # PL=4
                                b1, b2 = path[:2], path[-2:]
                                iebc = F
                                #if (np.all(icjs[b1]==1) and np.any(zs[b1]==6)) or \
                                #        (np.all(icjs[b2]==1) and np.any(zs[b2]!=6)):
                                    # np.any(zs[b1/b2]==6) would exclude C=CC=CC
                                if np.all(icjs[b1]==1) or np.all(icjs[b2]==1):
                                    iebc = T
                                iebcs.append(iebc)
                        #print('  iebcs=',iebcs, 'L0=',L0, 'nheav=',self.nheav, self.zs)
                        if np.all(iebcs):
                            impl4ebc = T
                    print('  impl4ebc = ', impl4ebc)

                    impl4 = (not impl4conj) and (not impl4ebc) #and (not impl4ni6ccn4)

                    # contains two POX3/SO2X2 ?
                    imlt2 = np.any([ len( set(iasmult).intersection(set(path)) ) > 1 for path in paths ])
                    #print('imlt2=', imlt2)

                    # contains -C(=O)-NX-C(=O)- ?
                    inco2 = (self.inco2 and L0==4)
                    #print('inco2=', inco2)

                    # conj ring with -R containing no more than 1 sp3-hybridized heavy atom ?
                    icr = (self.icr and (self.iconjs!=1).sum()<=1)
                    #print('icr=',icr)

                    ############ Note the two lines of code below can be replaced by the lines
                    ############ containing the keywor `newm.ats_ict0ex2`
                    # non-planar conj chain with N_I<=6 ?
                    # covering X=C/C=C\C=Y, X,Y could be C,N,O,S
                    #ictnp = self.is_conj_torsions_planar
                    #inpc = (np.all(self.iconjs==1) and ictnp and self.nheav<=6)

                    if impl4 and (not imlt2) and (not icr) and (not inco2): # and (not inpc):
                        iflex = T

            self._iflex = iflex
        return self._iflex

    @property
    def icr(self):
        """ if there exists 5 or 6-membered conjugated ring in the mol """
        if not hasattr(self, '_icr'):
            nca = (self.iconjs==1).sum()
            self._icr = ( (self.i5r and nca>=5) or (self.i6r and nca>=6) )
        return self._icr

    @property
    def inco2(self):
        """ if there exists env N-C(=O)-, where N could be sp2 or sp3 hybridized"""
        if not hasattr(self, '_inco'):
            patt = '[#6](=[#8,#16])~[#7]~[#6](=[#8,#16])'
            tf, _, _ = is_subg(self.oem, patt)
            self._inco = tf
        return self._inco

    @property
    def ats_ic4ex2(self):
        """ envs (as a list of atoms) that are conjugated with
        a) at least one X (=H,F,Cl,Br,I) atom attached to each of the
           two end sp2-hyb atoms
        """
        if not hasattr(self, '_ats_ic4ex2'):
            patt = '[^2;X3]~[^2]~[^2]~[^2;X3]'
            ifd, idxs, _ = is_subg(self.oem, patt, iop=1)
            self._ats_ic4ex2 = idxs
        return self._ats_ic4ex2

    @property
    def rsvdw_ref(self):
        if not hasattr(self, '_rsvdw_ref'):
            self._rsvdw_ref = [self.rsvdw] + self.rsvdw[..., np.newaxis]
        return self._rsvdw_ref

    @property
    def ats_ict0ex2(self):
        """ envs (as a list of atoms) that are conjugated torsion with
        a) dihedral angle is 0
        b) `ats_ic4ex2
        """
        if not hasattr(self, '_ats_ict0ex2'):
            ats = []
            if self.ats_ic4ex2:
                for idx in self.ats_ic4ex2:
                    if self.get_dihedral_angle(idx) < THRESH_TOR_PLANAR:
                        ats.append(idx)
            self._ats_ict0ex2 = ats
        return self._ats_ict0ex2

    @property
    def ats_ict0ex2vb(self):
        """ envs that are `ats_ict0ex2 and
        c) there exist one pair of end X atoms that satisfies
           d(x1,x2) < rvdw(x1)+rvdw(x2)
        """
        if not hasattr(self, '_ats_ict0ex2vb'):
            ats = []
            for idx in self.ats_ict0ex2:
                iasnb1 = np.setdiff1d(self.ias[self.bom[idx[0]]>0], idx)
                iasnb2 = np.setdiff1d(self.ias[self.bom[idx[-1]]>0], idx)
                #print('iasnb1,iasnb2=', iasnb1,iasnb2)
                if len( np.intersect1d(iasnb1,iasnb2) ) > 0:
                    # five membered ring
                    continue
                dspi = self.ds[iasnb1][:,iasnb2]
                dspiref = self.rsvdw_ref[iasnb1][:,iasnb2]
                iaspi = np.array( np.where(dspi < dspiref), dtype=int ).T
                #print('iaspi= ', iaspi)
                # now check if the end two atoms are bonded
                if len(iaspi) > 0:
                    for iasp in iaspi:
                        i1, i2 = iasp
                        ib, ie = iasnb1[i1], iasnb2[i2]
                        if self.bom[ib,ie] == 0:
                            #print('ib,ie=', ib,ie)
                            ats.append(idx)
            self._ats_ict0ex2vb = ats
        return self._ats_ict0ex2vb

    @property
    def ict0ex2vb(self):
        """ is there any env as in `ats_ict0ex2vb """
        if not hasattr(self, '_ict0ex2'):
            self._ict0ex2vb = (len(self.ats_ict0ex2vb) > 0)
        return self._ict0ex2vb

    @property
    def iciscc4(self):
        """ is it a cis- conjugated chain with 4 heavy atoms? """
        if not hasattr(self, '_iciscc4'):
            tf = F
            if self.ats_ic4ex2:
                for atsi in self.ats_ic4ex2:
                    if self.get_dihedral_angle(atsi) < 60.:
                        tf = T
                        break
            self._iciscc4 = tf
        return self._iciscc4

    @property
    def iasP5orS6(self):
        """ get idx of atoms that are i) P with valency of 5 or ii) S with valency of 6 """
        if not hasattr(self, '_iasP5orS6'):
            self._iasP5orS6 = self.get_iasP5orS6()
        return self._iasP5orS6

    def get_iasP5orS6(self):
        iasPS = []
        ts = is_subg(self.oem, '[#15,#16;X4]', iop=1)[1]
        for tsi in ts:
            ia = tsi[0]
            if self.hybs[ia] == 3:
                iasPS.append( tsi[0] )
        return iasPS

    @property
    def iasN3_nar(self):
        if not hasattr(self, '_iasN3'):
            self._iasN3 = self.get_iasN3_nar()
        return self._iasN3

    def get_iasN3_nar(self):
        """
        get atomic idx of N atoms satisfying
            i) CN = 3
           ii) not in an aromatic env
        Purpose: to identify hyper-conjugated atoms (with
        normally conjugated atoms as neighbors) before calling
        function `get_iconjs()
        """
        iasN3_nar = []
        ts = is_subg(self.oem, '[#7;X3;A]', iop=1)[1] # including >N-C=R (R=C<,N-,O)
        for tsi in ts:
            ia = tsi[0]
            if self.hybs[ia] == 2:
                # OEChem assigns a hyb of 2 to N in envs such as >N-C=R (Note: hyb of N in -N(=O)=O is 3)
                iasN3_nar.append( tsi[0] )
        return iasN3_nar

    @property
    def iconjs(self):
        """ is conjugated atomic env? """
        if not hasattr(self, '_iconjs'):
            self._iconjs = self.get_iconjs()
        return self._iconjs

    @property
    def iconjs_native(self):
        if not hasattr(self, '_iconjs2'):
            # Note that perceive from Coordination Number (CN) is not very realiable sometimes,
            # e.g., N in -N(=O)=O is sp2 hybridized, but CN=3
            cnsr = np.array([ co.cnsr[z] for z in self.zs ], dtype=int)
            self._iconjs2 = (self.cns < cnsr) # this automatically exclude >P(=O)-, >[S(=O)=O] as conj env
        return self._iconjs2

    def get_iconjs(self):
        """
        iconj : could be one of 0, 1 or 2
                0: not conjugated at all
                1: conjugated (normal case)
                2: hyper-conjugation, e.g., O-sp3 in Ph-OH
        """
        _iconjs = np.logical_and( self.hybs < 3, self.hybs > 0 )
        # reset `iconj to 0 for N in env -C(=O)N
        #for i in self.iasN3_nar:
        #    _iconjs[i] = F
        cas = self.iasv[_iconjs] # conjugated atoms
        ncas = np.setdiff1d(self.iasv, cas) #non-conj atoms
        iconjs = np.array(_iconjs, dtype=int)
        for i in ncas:
            zi = self.zs[i]
            #nnb = (self.g[i]>0).sum()
            #print('i, zi, nnb, cnr=', i,zi,nnb,cc.cnsr[zi])
            #if (zi in [7,16,]): # for Ph-SH, Ph-NH2, conj between Ph and R is very effective
            #    if np.any(self.aromatic[self.ias[self.g[i]>0]]):
            #        iconjs[i] = 2
            if zi in [7,8,16]: #9,16,17]:
                # hyper-conj via lone electron pair and Pi electron
                nbrsi = cas[ self.g[i,cas]>0 ]
                cnsr = np.array([ co.cnsr[self.zs[inb]] for inb in nbrsi ])
                if np.any( self.cns[nbrsi] < cnsr ):
                    iconjs[i] = 2
        return iconjs

    @property
    def atsr(self):
        if not  hasattr(self, '_atsr'):
            self._atsr = self.get_atsr()
        return self._atsr

    def get_atsr(self, namin=3, namax=7, remove_redudant=T):
        """ get ring nodes for ring
        made up of `namin- to `namax atoms

        We focus on those nodes which constitute the
        `extended smallest set of small unbreakable fragments,
        including aromatic rings, 3- and 4-membered rings
        (accompanied with high strain typically)
        """
        # first search for rings
        sets = []
        for i in range(namin, namax+1):
            #if i in [3,4,5]:
            pat_i = '*~1' + '~*'*(i-2) + '~*1'
            #else:
            #    pat_i = '*:1' + ':*'*(i-2) + ':*1'
            ifd, idxs, _ = is_subg(self.oem, pat_i, iop=1)
            for idx in idxs:
                if idx:
                    #print('idx=',idx)
                    _set = set(idx)
                    if _set not in sets:
                        sets.append(_set)
        if remove_redudant:
            # now remove those rings that are union of smaller rings
            n = len(sets)
            sets_remove = []
            ijs = itl.combinations( list(range(n)), 2 )
            sets_u = []
            for i,j in ijs:
                set_ij = sets[i].union( sets[j] )
                if (set_ij in sets) and (set_ij not in sets_remove):
                    sets_remove.append( set_ij )
            sets_u = cim.get_compl(sets, sets_remove)
        else:
            sets_u = sets
        return sets_u

    @staticmethod
    def is_part_of_smaller_ring(seti, sets):
        """ check if the ring atoms `seti are all part of
        any of the smaller rings """
        na = len(seti)
        _sets = []
        for setj in sets:
            if len(setj) < na:
                _sets.append(setj)
        _seti = list(seti)
        iss = []
        for a in _seti:
            ispart = F
            for setj in _sets:
                if a in setj:
                    ispart = T
                    break
            iss.append( ispart )
        return np.all(iss)

    @property
    def atsr_strain(self):
        if not hasattr(self, '_atsr_strain'):
            self._atsr_strain = self.get_atsr_strain()
        return self._atsr_strain

    def get_atsr_strain(self):
        atsr = self.get_atsr(namin=3, namax=7, remove_redudant=T)
        atso = []
        for i, _atsi in enumerate(atsr):
            na = len(_atsi)
            atsi = list(_atsi)
            # no matter what, if all atoms in this ring are constitutes
            # of even smaller ring, then exclude this ring
            if i>0 and StringM.is_part_of_smaller_ring(_atsi, atsr[:i]):
                continue
            else:
                tf = np.all(self.iconjs[atsi])
                if na == 5:
                    if not tf:
                        continue
                elif na == 6:
                    continue
                elif na > 6:
                    # include 7- or higher-membered ring iff the ring comprises
                    # atoms that are all conj
                    if not tf:
                        continue
            atso.append( _atsi )
        return atso


    @property
    def pls(self):
        if not hasattr(self, '_pls'):
            self._pls = self.get_pls_a()
        return self._pls

    def get_shortest_path(self, i, j):
        """ shortest path between i and j """
        a1 = self.oem.GetAtom( OEHasAtomIdx(i) )
        a2 = self.oem.GetAtom( OEHasAtomIdx(j) )
        path = []
        for ai in OEShortestPath(a1,a2):
            ia = ai.GetIdx()
            path.append(ia)
        return path

    @property
    def cobj(self):
        """ connectivity object, no hydrogen bond """
        if not hasattr(self, '_cobj'):
            self._cobj = cmc.Graph(self.g)
        return self._cobj

    @property
    def cobj_ext(self):
        """ connectivity object, hydrogen bond included """
        if not hasattr(self, '_cobj_ext'):
            g2 = self.g
            if np.any(self.ghb > 0):
                g2 = np.logical_or(self.g>0, self.ghb>0).astype(int)
            self._cobj_ext = cmc.Graph( g2 )
        return self._cobj_ext

    @property
    def plshb(self):
        if not hasattr(self, '_plshb'):
            self._plshb = self.cobj_ext.pls
        return self._plshb


    def get_pls_a(self):
        """
        get graph PathLength between all atoms
        """
        m = self.oem
        #OESuppressHydrogens(m, F, F, F)
        #nha = m.NumAtoms()
        pls = np.zeros((self.na, self.na)) #nha,nha))
        # To save time, compute PL between heavy atom only
        for ai in m.GetAtoms():
            ia = ai.GetIdx()
            for aj in m.GetAtoms():
                ja = aj.GetIdx()
                if ja > ia:
                    pls[ia,ja] = pls[ja,ia] = OEGetPathLength(ai,aj)
        return pls


    def get_pls(self):
        """
        get graph PathLength between heavy atoms first, then hydrogen atoms
        May be more efficient compared to `get_pls_a() for large mol?
        """
        m = self.clone()
        OESuppressHydrogens(m, F, F, F)
        nha = m.NumAtoms()
        pls = np.zeros((self.na, self.na)) #nha,nha))
        # To save time, compute PL between heavy atom only
        for ai in m.GetAtoms():
            ia = ai.GetIdx()
            for aj in m.GetAtoms():
                ja = aj.GetIdx()
                if ja > ia:
                    pls[ia,ja] = pls[ja,ia] = OEGetPathLength(ai,aj)
        # for adjacent atoms and second-closest atoms
        for ia in self.ias:
            for ja in self.ias:
                if (ja>ia) and (self.zs[ia]==1 or self.zs[ja]==1):
                    if self.g[ia,ja]:
                        pls[ia,ja] = pls[ja,ia] = 1
                    else:
                        nbrs1 = self.ias[self.g[ia]>0]
                        nbrs2 = self.ias[self.g[ja]>0]
                        if len(set(nbrs1).intersection(set(nbrs2))) == 1:
                            #print('--------- ia,ja = ', ia,ja)
                            pls[ia,ja] = pls[ja,ia] = 2
        # for distant atoms
        for ia in self.ias:
            for ja in self.ias:
                zi = self.zs[ia]
                zj = self.zs[ja]
                if ja>ia and pls[ia,ja]==0 and (zi==1 or zj==1) and self.g[ia,ja]==0:
                    if zi==1 and zj>1:
                        pl = pls[self.ias[self.g[ia]>0][0],ja]
                        nh = 1
                    elif zi>1 and zj==1:
                        pl = pls[self.ias[self.g[ja]>0][0],ia]
                        nh = 1
                    else:
                        pl = pls[self.ias[self.g[ja]>0][0], self.ias[self.g[ia]>0][0]]
                        nh = 2
                    _pl = pl + nh if pl > 0 else 0 # Note: for two atoms without a path, pl=0
                    pls[ia,ja] = pls[ja,ia] = _pl
        return pls

    @property
    def is_conj_torsions_planar(self):
        if not hasattr(self, '_ictp'):
            self._ictp = self.get_is_conj_torsions_planar()
        return self._ictp

    def get_is_conj_torsions_planar(self):
        iconjs = (self.hybs < 3) # don't exclude N3 in >N-C(=O)-, as we did in get_is_conj_amon()
        if iconjs.sum() < 4: return T
        iasv = self.iasv[iconjs]
        gv = self.g[iasv][:,iasv]
        zsv = self.zs[iasv]
        cnsv = self.cns[iasv]
        #print('cnsv=',cnsv)
        coordsv = self.coords[iasv]
        cs = find_cliques(gv)
        istat = T
        for csi in cs:
            #print('csi=',csi)
            gi = gv[csi][:,csi]
            zsi = zsv[csi]
            coordsi = coordsv[csi]
            cnsi = cnsv[csi]
            #print('cnsi=',cnsi)
            obj = MB.NBody( (zsi,coordsi), gi, icn=T, unit='degree', cns=cnsi) #
            mbs4 = obj.get_dihedral_angles()
            #print('mbs4=', obj.mbs4)
            _vs = []
            for k in mbs4:
                _vs += list(mbs4[k])
            vals = np.abs( np.array(_vs) )
            dvals = np.min( [ vals, np.abs(vals-180.) ], axis=0 )
            #print('vals=',vals, 'dvals=',dvals)
            self._dangs = vals
            if np.any(dvals > self.thresh_TOR_PLANAR):
                #print('  angs = ', vals)
                istat = F
                break
        return istat

    @property
    def L(self): # maximal length of a molecule
        return np.max(self.pls)

    @property
    def L0(self): # maximal length of a molecule (heavy atoms only)
        return np.max(self.pls[self.iasv][:,self.iasv])

    @property
    def H(self): # height of a molecule
        return self.nheav/(1.0 + self.L)

    def sort(self):
        """
        In a mol, H atom may appear in between heavy atoms, causing trouble
        later. Now we sort atoms to fix the potential problems.
        """
        newm = OEGraphMol()
        ats = []
        _ias = np.concatenate((self.ias[self.zs>1], self.ias[self.zs==1]))
        zs = self.zs[_ias]
        chgs = self.chgs[_ias]
        coords = self.coords[_ias]
        _bom = self.bom.copy()
        bom = _bom[_ias][:,_ias]
        newm = coc.newmol(zs, chgs, bom, coords).mol
        self.oem = newm
        self.zs = zs
        self.chgs = chgs
        self.coords = coords
        self.bom = bom
        self.tvs = bom.sum(axis=0)
        self.isorted = T

    def get_ab(self):
        """
        -- For heav atoms only
        get atoms and bonds info
        a2b: bond idxs associated to each atom
        b2a: atom idxs associated to each bond
        """
        b2a = [] #np.zeros((self.nb,2), np.int)
        b2idx = {}
        ib = 0 # idx of bonds involving heavy atoms only
        for i in range(self.nheav):
            for j in range(i+1,self.nheav):
                if self.bom[i,j] > 0:
                    if self.zs[i] > 1 and self.zs[j] > 1:
                        b2idx['%d-%d'%(i,j)] = ib
                        b2a.append( [i,j] )
                        ib += 1
        b2a = np.array(b2a, np.int)
        a2b = -1 * np.ones((self.nheav, 6), np.int) # assume maximally 6 bonds
        for ia in self.iasv:
            icnt = 0
            for ja in self.ias[ np.logical_and(self.bom[ia]>0,self.zs>1)]:
                pair = [ia,ja]; pair.sort()
                ib2 = b2idx['%d-%d'%(pair[0],pair[1])]
                assert ib2 <= ib  #np.all( self.zs[b2a[ib]] > 1 ):
                a2b[ia, icnt] = ib2
                icnt += 1
        return a2b, b2a

    def copy(self):
        mc = OEGraphMol()
        OECopyMol(mc, self.oem)
        return mc

    def clone(self):
        return self.copy()

    def check_valence_states(self):
        cnsDic = {5:[3], 6:[4], 7:[3], 8:[2], 9:[1], 14:[4], 16:[2,6], 17:[1]}
        bom = self.bom
        zs = []; chgs = []
        iok = True
        for ai in self.oem.GetAtoms():
            zi = ai.GetAtomicNum()
            if zi==1: continue
            chgi = ai.GetFormalCharge()
            nhi = ai.GetExplicitHCount() + ai.GetImplicitHCount()
            tvi = ai.GetValence()
            ia = ai.GetIdx()
            _bo = bom[ia]
            bosi = list( _bo[_bo>0] ); bosi.sort(reverse=True); sbo=['%s'%si for si in bosi]
            msg = ' ia=%d, zi=%d, tvi=%d, chgi=%d, bosi=%s'%(ia,zi,tvi,chgi,''.join(sbo))
            if tvi-chgi not in cnsDic[zi]:
                print(msg) # check if valency is ok
                iok = False
                break
        return iok

    def neutralise(self):
        """
        neutralise a molecule, typically a protein
        """
        assert self.suppressH, '#ERROR: pls set `suppressH=True'
        m = self.copy()
        obsolete = """zs = self.zs
        numHs = []; tvs = []; atoms = []
        for ai in m.GetAtoms():
            atoms.append( ai )
            numHs.append( ai.GetExplicitHCount() + ai.GetImplicitHCount() )
            tvs.append( ai.GetValence() )

        self.get_charged_pairs()
        for i in range(self.na):
            ai = atoms[i]
            ci = self.charges[i]
            nhi = numHs[i]
            if ci != 0:
                if i not in self.cpairs.ravel():
                    msg = ' zi = %d, tvi = %d, ci = %d, neib = %d'%(self.zs[i], tvs[i], ci, cnsDic[zs[i]])
                    assert tvs[i] - ci == cnsDic[zs[i]], msg
                    if nhi == 0 and ci > 0:
                        # in the case of >[N+]<, i.e., N with CoordNum = 4
                        # we don't have to do anything
                        continue
                    ai.SetFormalCharge( 0 )
                    ai.SetImplicitHCount( nhi - ci )
                    print('i, zi, ci, nH = ', i, self.zs[i], ci, numHs[i])
                else:
                    print('atom %d in a bond like ~[A+]~[B-]'%i) """
        OERemoveFormalCharge(m) # note that for quaternary amines (>[N+]<), charges retain
        OEAddExplicitHydrogens(m)
        OESet3DHydrogenGeom(m)
        # note that H attached to sp2-hybridized and charged N, e.g., N in =[NH2+] won't
        # be removed by OERemoveFormalCharge(), now we do this manually

        obsolete="""cnsDic = {5:3, 6:4, 7:3, 8:2, 9:1, 14:4, 17:1}

        bom = get_bom(m)
        zs = []; chgs = []
        for ai in m.GetAtoms():
            zi = ai.GetAtomicNum()
            chgi = ai.GetFormalCharge()
            nhi = ai.GetExplicitHCount() + ai.GetImplicitHCount()
            tvi = ai.GetValence()
            if chgi != 0:
                if chgi==1 and nhi==0: continue
                ia = ai.GetIdx()
                _bo = bom[ia]
                bosi = list( _bo[_bo>0] ); bosi.sort(reverse=True)
                msg = ' zi=%d, tvi=%d, chgi=%d, bosi=%d'%(zi,tvi,chgi,''.join(bosi))
                assert tvi-chgi == cnsDic[zi], msg # check if valency is ok
                assert chgi==1 and zi==7 and nhi>=1
                ai.SetFormalCharge( 0 )
                for bond in ai.GetBonds():
                    aj = bond.GetNbr(ai)
                    if aj.GetAtomicNum() == 1:
                        m.DeleteAtom( aj ) # remove the 1st H atom found
                        break
        OEFindRingAtomsAndBonds(m) """
        self.oem = m

    def annihilate_chgs(self):
        """
        chgs in some SMILES can be totally skipped.
        _____________________________________________
         group         SMILES          purged SMILES
        -------       --------        ---------------
        -NO2        -[N+](=O)[O-]        -N(=O)=O
        >CN2        >C=[N+]=[N-]         >C=N#N
        -NC         -[N+]#[C-]           -N$C (i.e., BO(N-C) = 4)
        _____________________________________________

        In cases like [NH3+]CCC(=O)[O-], the chgs retain.
        """
        na = self.na
        ias = np.arange(na)
        chgs = self.chgs
        zs = self.zs
        bom = self.bom
        if np.any(chgs!= 0):
            ias1 = ias[chgs==1]
            ias2 = ias[chgs==-1]
            bs = {} # store the idx of bonds for update of BO
            cs = {} # store the idx of atom for update of charge
            irev = False # revise `bom and `chgs?
            visited = dict( zip(range(na), [False,]*na) )
            for ia1 in ias1:
                for ia2 in ias2:
                    bo12 = bom[ia1,ia2]
                    if bo12 > 0:
                        assert not (visited[ia1] or visited[ia2]), \
                                  '#ERROR: visted before?'
                        visited[ia1] = visited[ia2] = True
                        bo12 += 1
                        irev = True
                        pair = [ia1,ia2]; pair.sort()
                        bs[ tuple(pair) ] = bo12
                        bom[ia1,ia2] = bom[ia2,ia1] = bo12
                        cs[ia1] = chgs[ia1] - 1
                        cs[ia2] = chgs[ia2] + 1
                        chgs[ia1] = cs[ia1]
                        chgs[ia2] = cs[ia2]
            if irev:
                csk = cs.keys()
                for ai in self.oem.GetAtoms():
                    idx = ai.GetIdx()
                    if idx in csk:
                        ai.SetFormalCharge( cs[idx])
                bsk = bs.keys()
                for bi in self.oem.GetBonds():
                    ias12 = [bi.GetBgnIdx(), bi.GetEndIdx()]
                    ias12.sort()
                    ias12u = tuple(ias12)
                    if ias12u in bsk:
                        bi.SetOrder( bs[ias12u] )
        self.bom = bom
        self.chgs = np.array(chgs)

    @property
    def rsvdw(self):
        if not hasattr(self, '_rsvdw'):
            self._rsvdw = Elements().rvdws[self.zs]
        return self._rsvdw

    @property
    def rscov(self):
        if not hasattr(self, '_rscov'):
            self._rscov = Elements().rcs[self.zs]
        return self._rscov

    @property
    def geom(self):
        if not hasattr(self, '_geom'):
            self._geom = GM.Geometry(self.coords, ds=self.ds)
        return self._geom

    def get_dihedral_angle(self, qats):
        return self.geom.get_dihedral_angle(qats, unit='degree')

    @property
    def iasdha(self):
        """ a list of idx of atoms that form hydrogen bond
        A typical hydrogen bond comprises of 3 parts: D...H-A"""
        if hasattr(self,'_iasdha'):
            return self._iasdha
        ifdhbd, _iashbd, _ = is_subg(self.oem, sma_hbd, iop=1)
        ifdhba, _iashba, _ = is_subg(self.oem, sma_hba, iop=1)
        iashbd = [ i[0] for i in _iashbd ]
        iashba = [ i[0] for i in _iashba ]
        if not all([ifdhbd,ifdhba]):
            self._iasdha = []
            return self._iasdha
        nad = len(iashbd); naa = len(iashba)
        zs = self.zs
        ds = self.ds
        dhas = []
        for i0 in range(nad):
            for j0 in range(naa):
                i,j = iashbd[i0], iashba[j0]
                if i==j: continue
                # now find H's attached to HB donor
                iash = self.ias[ np.logical_and(self.zs==1, self.g[i]>0) ]
                for h in iash:
                    rvdw0 = self.rsvdw[[h,j]].sum()
                    rc0 = self.rscov[[h,j]].sum()
                    ang = self.geom.get_angle([i,h,j], unit='degree')
                    iDHA = self.get_is_dha_valid([zs[i],zs[j]],ang)
                    if ds[h,j] > rc0 and ds[h,j] <= rvdw0 and iDHA:
                        dhas.append( [i,h,j] )
        self._iasdha = dhas
        return self._iasdha

    @property
    def ghb(self):
        if not hasattr(self, '_ghb'):
            ghb = np.zeros((self.na,self.na))
            for i,h,j in self.iasdha:
                ghb[h,j] = ghb[j,h] = 0.5
            self._ghb = ghb
        return self._ghb

    @property
    def ghbv(self):
        if not hasattr(self, '_ghbv'):
            ghbv = np.zeros((self.nheav,self.nheav))
            for i,h,j in self.iasdha:
                ghbv[i,j] = ghbv[j,i] = 0.5
            self._ghbv = ghbv
        return self._ghbv

    def get_is_dha_valid(self, pair, ang):
        """ is it a valid hydrogen bond, of form `D --- H-A`,
        where D: Donor, A: Acceptor """
        iok = F
        pair.sort()
        pair = tuple(pair)
        if pair in [ (7,7), (7,8), (8,8) ]:
            angref = 180.
        else:
            raise Exception('#Todo')
        if abs(ang-angref) <= THRESH_DHA_ANGLE:
            iok = T
        return iok

    @property
    def ats_pipistack(self):
        if not hasattr(self, '_pipi'):
            self._pipi = self.get_ats_pipistack()
        return self._pipi

    def get_ats_pipistack(self):
        """ Todo: """
        raise Exception('Todo')
        ats = []
        return set(ats)



    @property
    def gvdw(self):
        # note that the thus-obtained bonds include hydrogen bonds
        # from the function `perceive_hbs()
        # The criteria of assigning a non covalent bond is that the
        # interatomic distance is .le. sum of vdw radii, and that there
        # are at least 5 heavy atoms connecting these two end atoms
        if not hasattr(self, '_gvdw'):
            _ = self.get_gvdw()
        return self._gvdw

    @property
    def ocs(self):
        if not hasattr(self, '_ocs'):
            self._ocs = self.get_ocs()
        return self._ocs

    def get_ocs(self):
        patt = '[#6;X3]=O'
        _, idx, _ = is_subg(self.oem, patt, iop=1)
        return idx

    @property
    def ocns(self):
        if not hasattr(self, '_ocns'):
            self._ocns = self.get_ocns()
        return self._ocns

    def get_ocns(self):
        patt = '[#7][#6;X3]=O'
        _, idx, _ = is_subg(self.oem, patt, iop=1)
        return idx

    @property
    def ncbs(self):
        """ non-covalent bonds """
        if not hasattr(self, '_ncbs'):
            self._ncbs = self.get_ncbs()
        return self._ncbs

    @property
    def ncbsv(self):
        if not hasattr(self, '_ncbsv'):
            self._ncbsv = self.get_ncbsv()
        return self._ncbsv

    @property
    def gvdw(self):
        if not hasattr(self, '_gvdw'):
            gv = np.zeros((na,na))
            for seti in self.ncbs:
                i,j = list(seti)
                gv[i,j] = gv[j,i] = 0.2
            self._gvdw = gv
        return self._gvdw

    @property
    def gvdwv(self):
        if not hasattr(self, '_gvdwv'):
            gvv = np.zeros((na,na))
            for seti in self.ncbsv:
                i,j = list(seti)
                gvv[i,j] = gv[j,i] = 0.2
            self._gvdwv = gvv
        return self._gvdwv


    zsvdw = set([1,7,8,9,15,16,17,33,34,35,53])
    def get_ncbs(self):
        """ get all non-covalent bonds (including both
        intra- and inter-molecular)

        Attention should be paid to the var `plmin, which is
        defaulted to 4.

        pl = 4 corresponds to the structure below

                         H .
                       /    .
                      /       .
                     O         O--H
                     \        /
                      \      /
                       CH---CH
                       /     \
                      /       \

        while pl=5 may be associated with the following intra-molecular
        vdw bond
                        H ... H
                       /       \
                      /         \
               H3C---CH          C---CH3
                     \          /
                      \        /
                       CH----CH
                       /      \
                      /        \
        """
        rsvdw = self.rsvdw
        m = self.oem
        #assert OEAddExplicitHydrogens(m)
        ds = self.ds
        g = self.g
        na = self.na
        ias = self.ias
        pls = self.pls
        ncbs = []
        for i in range(na):
            for j in range(i+1,na):
                pair = [i,j]
                pair.sort()
                zsij = self.zs[pair]
                cnsij = self.cns[pair]
                zi,zj = zsij
                #nH = (np.array([zi,zj]) == 1).sum()
                dijmin = self.rscov[[i,j]].sum() + 0.45
                dijmax = rsvdw[i]+rsvdw[j] + 0.2
                dij = ds[i,j]
                if g[i,j]==0 and dij<dijmax and dij>dijmin:
                    pl = pls[i,j]
                    plmin = 4
                    if pl==0 or pl>=plmin:
                        #print('i,j,zi,zj=', i,j,zi,zj)
                        if np.any( np.logical_and(zsij==6, cnsij==4) ): #set([zi,zj]) < self.zsvdw:
                            # no vdw bond is gonna formed between any atom and C-sp3
                            continue
                        #else:
                        #    raise Exception('Todo')
                        #    if (set([i,j]) <= self.ats_pipistack):
                        #        # pi-pi stacking
                        #        raise Exception('Todo')
                        #    else:
                        #        continue
                        if pair not in ncbs:
                            ncbs.append(pair)

        # now remove vdw bond formed between X and H in system R1-X ... H-R2
        # where X=F,Cl,Br,I or other non-H and CN=1 atom (e.g., C in -[N+]#[C-])
        obsolete = """_seta = set()
        for b in self.ncbs:
            _seta.update(b)
        atsv = list(_seta)
        buff = []
        for j in atsv:
            if self.cns[j] == 1:
                tfs = ( gv[j]>0 )
                if np.any(tfs):
                    dsj = ds[j][tfs]
                    jas = ias[tfs]
                    jnb = jas[dsj==np.min(dsj)][0]
                    bj = set([j,jnb])
                    if bj not in buff:
                        buff.append(bj)
                        pair = [j,jnb]; pair.sort()
                    ks = np.setdiff1d(jas,[jnb])
                    for k in ks:
                        ncbs.remove( set([j,k]) ) """
        return ncbs


    def get_ncbsv(self):
        """ get the pair of heavy atoms associated with
        each of the non-covalent bonds """
        gvv = np.zeros((na,na))
        ncbsv = []
        for b in self.ncbs:
            i,j = list(b)
            zi = self.zs[i]
            zj = self.zs[j]
            iu = i
            if zi == 1:
                iu = ias[g[i]==1][0]
            ju = j
            if zj == 1:
                ju = ias[g[j]==1][0]
            if iu != ju and g[iu,ju]==0:
                p = [iu,ju]; p.sort()
                ncbsv.append(p)
        return ncbsv


    @property
    def ncbs_inter(self):
        if not hasattr(self, '_ncbs2'):
            ncbs2 = []
            for b in self.ncbs:
                i,j = list(b)
                if self.pls[i,j] > 0:
                    ncbs2.append(b1)
            self._ncbs2 = ncbs2
        return self._ncbs2

    @property
    def ncbs_intra(self):
        if not hasattr(self, '_ncbs1'):
            ncbs1 = []
            for b in self.ncbs:
                i,j = list(b)
                if self.pls[i,j] == 0:
                    ncbs1.append(b1)
            self._ncbs1 = ncbs1
        return self._ncbs1



class smiles_db(object):

    def __init__(self, obj, sort=T):
        if isinstance(obj,(tuple,list)):
            ss1 = obj
        elif isinstance(obj,str):
            assert os.path.exists(obj), '#ERROR: file does not exist!'
            ss1 = [ si.strip().split()[0] for si in open(obj).readlines() ]
        else:
            raise Exception('unknown input object!')
        nm = len(ss1)
        ims = np.arange(nm).astype(int)
        self.ims = ims
        nas = []
        ss2 = []
        iN5s = []
        for si in ss1:
             om = StringM(si, suppressH=F, simple=T)
             iasN5 = om.ias[ np.logical_and(om.zs==7, om.tvs==5) ]
             iN5 = F
             for iaN in iasN5:
                 _bosi = om.bom[iaN]
                 bosi = _bosi[_bosi>0]
                 bosi.sort()
                 bosi = bosi[::-1]
                 sbo = ''.join([ '%d'%bo for bo in bosi ])
                 if not (sbo=='32' or ((om.zs[om.bom[iaN]>0] == 8).sum() == 2)):
                     iN5 = T
                     break
             iN5s.append(iN5)
             ss2.append( oem2can(om.oem) ) # oechem can strings
             nas.append(om.nheav)
        nas = np.array(nas,dtype=int)
        iN5s = np.array(iN5s, dtype=bool)
        ns = np.unique(nas) #dtype=int)
        if sort:
            ss3 = []
            nms = []
            nsheav = []
            imap = []
            iN5s_new = []
            for ni in ns:
                idx = ims[ni==nas]
                ssi = np.array(ss2)[idx]
                irs = np.argsort(ssi)
                idx2 = idx[irs] #.sort()
                iN5s_new += list(iN5s[idx2])
                nmi = len(ssi)
                nms.append(nmi)
                nsheav += [ni]*nmi
                ss3 += list(ssi[irs])
                imap += list(idx2)
            print(' ** smiles were sorted by num_heav_atom and then name')
            imap = np.array(imap, dtype=int)
            iN5s = np.array(iN5s_new, dtype=bool)
        else:
            ss3 = ss2
            nsheav = nas
            nms = None
            imap = None
        self.smiles = ss3
        self.nsheav = nsheav
        self.imap = imap
        self.iN5s = iN5s
        self.nms = nms


def is_subsub(q, ts):
    """
    check is `q is a subset of any subset in set `ts
    """
    iok = False
    for tsi in ts:
        if set(q) <= tsi:
            iok = True; break
    return iok

def is_subg(t, q, qidxs=[], woH=False, iop=0, rule='none', kekulize=False):
    """
    check if `q is a subgraph of `t

    if iop .lt. 0, then the matched atom indices in `t will also
    be part of the output
    """

    if type(t) is str:
        m = OEGraphMol()
        iok = OESmilesToMol(m, t)

        # lines below does not work!!
        if kekulize:
            OEClearAromaticFlags(m)
            OEKekulize(m)
    else:
        m = t

    if woH:
        OESuppressHydrogens(m, F, F, F)
        #pass #OESuppressH

    ss = OESubSearch(q)
    iok = OEPrepareSearch(m, ss)
    isg = ss.SingleMatch(m)

    idxs = []; in_subm = False
    if iop > 0:
        idxs = []; idxs_aux = []
        if isg:
            for i,match in enumerate(ss.Match(m)):
                idxsQ_i = []; idxsT_i = []
                for ma in match.GetAtoms():
                    idxsQ_i.append( ma.pattern.GetIdx() )
                    idxsT_i.append( ma.target.GetIdx() );
                seqs = np.argsort(idxsQ_i);
                #print ' -- seqs = ',seqs
                idxsT_iu = list(np.array(idxsT_i,np.int)[seqs])
                set_i = set(idxsT_iu)
                if set_i not in idxs_aux:
                    # it's always safe to append the atomic indices whose
                    # sorted ones is unique in a auxiliary set `idxs_aux
                    idxs.append( idxsT_iu )
                    idxs_aux.append( set(idxsT_iu) )
                #print 'idxs = ', idxs

            if rule in ['exclusive',]:
                # this means that the `q to be searched has unique existence
                # e.g., suppose we wanna know if the structure contains a
                # 'S=O', then 'S(=O)=O' does not count; this could be told by
                # if two matched set of idxs is joint
                if len(idxs) > 1:
                    idxsU = []
                    for idxs_i in idxs:
                        if not is_joint_vec(idxs_i, cim.get_compl(idxs, [idxs_i,])):
                            idxsU.append(idxs_i)
                    idxs = idxsU
                    if len(idxs) == 0: isg = False

            if qidxs != []:
                # check if `qidxs is a subset of `idxs
                in_subm = ( in_subm or np.all([qidx in idxs for qidx in qidxs]))
    op = [isg, idxs, in_subm ]
    return op


def find_cliques(g1):
    """
    the defintion of `clique here is not the same
    as that in graph theory, which states that
    ``a clique is a subset of vertices of an
    undirected graph such that every two distinct
    vertices in the clique are adjacent; that is,
    its induced subgraph is complete.''
    However, in our case, it's simply a connected
    subgraph, or a fragment of molecule. This is useful
    only for identifying the conjugated subset of
    atoms connected all by double bonds or bonds of
    pattern `double-single-double-single...`
    """

    n = g1.shape[0]
    G = nx.Graph(g1)
    if nx.is_connected(G):
        cliques = [ np.arange(n), ]
    else:
        cliques = []
        sub_graphs = nx.connected_component_subgraphs(G)
        for i, sg in enumerate(sub_graphs):
            cliques.append( list(sg.nodes()) )
    return cliques


def find_neighbors(g, ias):
    """
    get the neighbors of a list of atoms `ias
    """
    neibs = []
    na = g.shape[0]
    ias0 = np.arange(na)
    for ia in ias:
        for ja in ias0[ g[ia] > 0 ]:
            if ja not in ias:
                neibs.append( ja )
    return neibs


